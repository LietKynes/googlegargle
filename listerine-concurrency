#!/bin/bash
#./listerine - a companion to the google gargle project
#relies on /proc/, googlegrape, aria2c, curl, and youtube-dl

# LietKynes fork
# This version runs googlegargle in parallel for situations like mine where I'm throttled at 80k per download, but I can have several in parallel. I don't know if google or my ISP does the throttling.
# By default this script runs 3 processes in parallel, but you can adjust the number in real-time like this:
# echo 30 > _max_concurrent
# To stop the script safely you should do this:
# echo 0 > _max_concurrent
#

GARGLE=./googlegargle

if [ ! -f $GARGLE ]; then
    echo "Couldn't find googlegargle. Are you sure you cloned everything from the git repository?"
    exit 2
fi

# Change the username below to something unique to you. ALPHANUMERIC ONLY!
USERNAME=
if [ -f _username ]; then
    read USERNAME < _username
fi

if [ -z $USERNAME ]; then
    echo "Write your username in the file _username, for example:"
    echo "echo PrinceAlbert > _username"
    exit 1
fi

EXTERN_IP=`curl --silent ipv4.icanhazip.com` #Do not change without good reason, or underscor will eat your brains
SERVER=199.48.254.90:8081
RAN=0 #how many processes ran so far

mkdir -p _logs
QUEUE_DIR=_queue-$$
trap "rm -rf $QUEUE_DIR" 0
mkdir -p $QUEUE_DIR
for PID in $(ls $QUEUE_DIR); do
    echo "Please clean up $QUEUE_DIR/"
    exit 1
done
echo -n "Registering with $SERVER as $USERNAME with IP $EXTERN_IP... "
curl -s http://$SERVER/introduce/$USERNAME/$EXTERN_IP
echo
RUNNING=0
MAX=1
while [ $MAX -gt 0 -o $RUNNING -gt 0 ]; do
    if [ -f ./_max_concurrent ]; then
        read MAX < ./_max_concurrent
    else
        MAX=1
    fi
    if [ -f STOP ]; then 
	echo "I see a file called STOP. Stopping."
	MAX=0
    fi
    RUNNING=0
    for PID in $(jobs -p); do
        if kill -0 "$PID" 2>/dev/null; then
            let "RUNNING = $RUNNING + 1"
        fi
    done
    echo -n "There are $RUNNING running jobs (limit $MAX). PIDs:"
    for PID in $(ls $QUEUE_DIR/); do
        echo -n " $PID"
    done
    if [ $MAX -eq 0 ]; then
        echo -n ". Limit is 0, will exit when these jobs end"
    fi
    echo .
    sleep 5
    
    for PID in $(ls $QUEUE_DIR/); do
        read id < $QUEUE_DIR/"$PID"
        if kill -0 "$PID" 2>/dev/null; then
            echo -n "googlegargle status for $id: 	"
            tail -n1 _logs/"$id".log
            continue
        fi
        SEPDIB=$(echo "$id" | sed 's/-//g' | cut -c1)
        SECDIB=$(echo "$id" | sed 's/-//g' | cut -c2)
        THIRDIB=$(echo "$id" | sed 's/-//g' | cut -c3)
        if [ -f "$SEPDIB/$SECDIB/$THIRDIB/$id/$id.flv" -a ! -f "$SEPDIB/$SECDIB/$THIRDIB/$id/$id.flv.aria2" ]; then
            hash=`sha1sum "$SEPDIB/$SECDIB/$THIRDIB/$id/$id.flv"|awk '{print $1}'`
            size=`du -b "$SEPDIB/$SECDIB/$THIRDIB/$id/$id.flv"|awk '{print $1}'`
            echo "googlegargle finished for $id."
            curl "http://$SERVER/finishVid/$USERNAME/$id/$size/$hash" && rm -f $QUEUE_DIR/"$PID"
        else
            #echo "Something is wrong with id $id, PID $PID" | tee -a _ERRROS
            #$MAX=0
            echo -n ""
        fi
    done
    
    while [ $RUNNING -lt $MAX ]; do
        echo -n "Getting an id from $SERVER... "
        id=`curl --silent http://$SERVER/getID/$USERNAME | sed "s/[^0-9\\-]//g"`
        echo "got $id"
        $GARGLE -- "$id" 1>>_logs/"$id".log 2>&1 &
        echo $id > $QUEUE_DIR/$!
        
        echo "googlegargle started for $id with PID $!"
        let "RAN = $RAN + 1"
        let "RUNNING = $RUNNING + 1"
    done
done
echo "Ran a total of $RAN downloads."
